package main

import "fmt"

//Реализовать пересечение двух неупорядоченных множеств.
func main() {
	set1 := []interface{}{"b", "b", "c", "d", "e", "f", "g", "a", "a", "a"}
	set2 := []interface{}{"d", "g", "k", "a", "a", "b", "b", "b", "c"}
	fmt.Println(getIntersection(set1, set2))
}

//Выполним пересечение множеств за время O(N), используя немного памяти с помощью map
func getIntersection(set1, set2 []interface{}) []interface{} {
	// Создадим map, где ключом будет элемент, а значением кол-во вхождений элемента в множество
	counter := make(map[interface{}]int)
	// Объявим пересечение
	var intersection []interface{}

	// Инициализируем пересечение, длина которого будет равна длине короткого множества
	// Длина пересечения не может быть больше чем короткое множество
	if len(set1) < len(set2) {
		intersection = make([]interface{}, 0, len(set1))
	} else {
		//Поменяем множества местами, чтобы в дальнейшем в map записывать вхождения элементов короткого множества
		set1, set2 = set2, set1
		intersection = make([]interface{}, 0, len(set2))
	}

	// Найдем количество вхождений каждого элемента первого множества
	// В цикле пройдемся по каждому элементу первого множества
	// Если элемент не встречается в map, кладем его со значением 1
	// Если элемент уже записан в map, увеличеваем значение на 1
	for _, el := range set1 {
		if _, ok := counter[el]; !ok {
			counter[el] = 1
		} else {
			counter[el] += 1
		}
	}

	// Соотнесем число вхождений элементов первого множества и число вхождений элементов второго множества
	// В цикле пройдемся по каждому элементу второго множества
	// Если элемент встречается в map и его значение больше 0, уменьшим значение на 1 и  добавим элемент в пересечение
	for _, el := range set2 {
		if count, ok := counter[el]; ok && count > 0 {
			counter[el] -= 1
			intersection = append(intersection, el)
		}
	}

	//Вернем пересечение
	return intersection
}
